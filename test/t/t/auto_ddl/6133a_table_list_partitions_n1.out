SELECT pg_sleep(1);--to ensure all objects are replicated
 pg_sleep 
----------
 
(1 row)

--creating the necessary pre-reqs and then switching to the appuser role
CREATE SCHEMA IF NOT EXISTS s613;
INFO:  DDL statement replicated.
CREATE SCHEMA
GRANT ALL PRIVILEGES ON SCHEMA s613 TO appuser;
INFO:  DDL statement replicated.
GRANT
SET ROLE appuser;
SET
SET search_path TO s613, public;
SET
-----------------------------
-- List Partitioning
-----------------------------
-- Create a list partitioned table with primary key
CREATE TABLE sales_list (
    sale_id INT,
    sale_region TEXT,
    sale_amount DECIMAL,
    PRIMARY KEY (sale_id, sale_region)
) PARTITION BY LIST (sale_region);
INFO:  DDL statement replicated.
CREATE TABLE
-- Add partitions to the sales_list table
CREATE TABLE sales_list_east PARTITION OF sales_list
    FOR VALUES IN ('East');
INFO:  DDL statement replicated.
CREATE TABLE
CREATE TABLE sales_list_west PARTITION OF sales_list
    FOR VALUES IN ('West');
INFO:  DDL statement replicated.
CREATE TABLE
-- Insert data into the sales_list table
INSERT INTO sales_list (sale_id, sale_region, sale_amount) VALUES
(1, 'East', 100.0),
(2, 'West', 200.0),
(3, 'East', 150.0);
INSERT 0 3
SELECT * FROM get_table_repset_info('sales_list'); -- Expect both parent and child tables in default repset
 nspname |     relname     | set_name 
---------+-----------------+----------
 s613    | sales_list      | default
 s613    | sales_list_east | default
 s613    | sales_list_west | default
(3 rows)

SELECT * FROM sales_list ORDER BY sale_id; -- Expect 3 rows
 sale_id | sale_region | sale_amount 
---------+-------------+-------------
       1 | East        |       100.0
       2 | West        |       200.0
       3 | East        |       150.0
(3 rows)

-- Alter the sales_list table to add a new partition
CREATE TABLE sales_list_north PARTITION OF sales_list
    FOR VALUES IN ('North');
INFO:  DDL statement replicated.
CREATE TABLE
-- Insert data into the new partition
INSERT INTO sales_list (sale_id, sale_region, sale_amount) VALUES
(4, 'North', 250.0);
INSERT 0 1
-- Validate structure and data after adding new partition
\d+ sales_list_east
                                         Table "s613.sales_list_east"
   Column    |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
-------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 sale_id     | integer |           | not null |         | plain    |             |              | 
 sale_region | text    |           | not null |         | extended |             |              | 
 sale_amount | numeric |           |          |         | main     |             |              | 
Partition of: sales_list FOR VALUES IN ('East')
Partition constraint: ((sale_region IS NOT NULL) AND (sale_region = 'East'::text))
Indexes:
    "sales_list_east_pkey" PRIMARY KEY, btree (sale_id, sale_region)
Access method: heap

\d+ sales_list_west
                                         Table "s613.sales_list_west"
   Column    |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
-------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 sale_id     | integer |           | not null |         | plain    |             |              | 
 sale_region | text    |           | not null |         | extended |             |              | 
 sale_amount | numeric |           |          |         | main     |             |              | 
Partition of: sales_list FOR VALUES IN ('West')
Partition constraint: ((sale_region IS NOT NULL) AND (sale_region = 'West'::text))
Indexes:
    "sales_list_west_pkey" PRIMARY KEY, btree (sale_id, sale_region)
Access method: heap

\d+ sales_list_north
                                        Table "s613.sales_list_north"
   Column    |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
-------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 sale_id     | integer |           | not null |         | plain    |             |              | 
 sale_region | text    |           | not null |         | extended |             |              | 
 sale_amount | numeric |           |          |         | main     |             |              | 
Partition of: sales_list FOR VALUES IN ('North')
Partition constraint: ((sale_region IS NOT NULL) AND (sale_region = 'North'::text))
Indexes:
    "sales_list_north_pkey" PRIMARY KEY, btree (sale_id, sale_region)
Access method: heap

\d+ sales_list
                                     Partitioned table "s613.sales_list"
   Column    |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
-------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 sale_id     | integer |           | not null |         | plain    |             |              | 
 sale_region | text    |           | not null |         | extended |             |              | 
 sale_amount | numeric |           |          |         | main     |             |              | 
Partition key: LIST (sale_region)
Indexes:
    "sales_list_pkey" PRIMARY KEY, btree (sale_id, sale_region)
Partitions: sales_list_east FOR VALUES IN ('East'),
            sales_list_north FOR VALUES IN ('North'),
            sales_list_west FOR VALUES IN ('West')

SELECT * FROM get_table_repset_info('sales_list'); -- Expect the new partition to be listed
 nspname |     relname      | set_name 
---------+------------------+----------
 s613    | sales_list       | default
 s613    | sales_list_east  | default
 s613    | sales_list_west  | default
 s613    | sales_list_north | default
(4 rows)

SELECT * FROM sales_list ORDER BY sale_id; -- Expect 4 rows
 sale_id | sale_region | sale_amount 
---------+-------------+-------------
       1 | East        |       100.0
       2 | West        |       200.0
       3 | East        |       150.0
       4 | North       |       250.0
(4 rows)

-- Create a list partitioned table without primary key
CREATE TABLE products_list (
    product_id INT,
    product_category TEXT,
    product_name TEXT
) PARTITION BY LIST (product_category);
INFO:  DDL statement replicated.
CREATE TABLE
-- Add partitions to the products_list table
CREATE TABLE products_list_electronics PARTITION OF products_list
    FOR VALUES IN ('Electronics');
INFO:  DDL statement replicated.
CREATE TABLE
CREATE TABLE products_list_clothing PARTITION OF products_list
    FOR VALUES IN ('Clothing');
INFO:  DDL statement replicated.
CREATE TABLE
-- Insert data into the products_list table
INSERT INTO products_list (product_id, product_category, product_name) VALUES
(1, 'Electronics', 'Laptop'),
(2, 'Clothing', 'Shirt'),
(3, 'Electronics', 'Smartphone');
INSERT 0 3
-- Validate structure and data
\d+ products_list
                                      Partitioned table "s613.products_list"
      Column      |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
------------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 product_id       | integer |           |          |         | plain    |             |              | 
 product_category | text    |           |          |         | extended |             |              | 
 product_name     | text    |           |          |         | extended |             |              | 
Partition key: LIST (product_category)
Partitions: products_list_clothing FOR VALUES IN ('Clothing'),
            products_list_electronics FOR VALUES IN ('Electronics')

SELECT * FROM get_table_repset_info('products_list'); -- Expect both parent and child tables in default_insert_only set
 nspname |          relname          |      set_name       
---------+---------------------------+---------------------
 s613    | products_list             | default_insert_only
 s613    | products_list_electronics | default_insert_only
 s613    | products_list_clothing    | default_insert_only
(3 rows)

SELECT * FROM products_list ORDER BY product_id; -- Expect 3 rows
 product_id | product_category | product_name 
------------+------------------+--------------
          1 | Electronics      | Laptop
          2 | Clothing         | Shirt
          3 | Electronics      | Smartphone
(3 rows)

-- Alter the products_list table to add a primary key
ALTER TABLE products_list ADD PRIMARY KEY (product_id, product_category);
INFO:  DDL statement replicated.
ALTER TABLE
-- Validate structure and data after adding primary key
\d+ products_list
                                      Partitioned table "s613.products_list"
      Column      |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
------------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 product_id       | integer |           | not null |         | plain    |             |              | 
 product_category | text    |           | not null |         | extended |             |              | 
 product_name     | text    |           |          |         | extended |             |              | 
Partition key: LIST (product_category)
Indexes:
    "products_list_pkey" PRIMARY KEY, btree (product_id, product_category)
Partitions: products_list_clothing FOR VALUES IN ('Clothing'),
            products_list_electronics FOR VALUES IN ('Electronics')

\d+ products_list_clothing
                                        Table "s613.products_list_clothing"
      Column      |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
------------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 product_id       | integer |           | not null |         | plain    |             |              | 
 product_category | text    |           | not null |         | extended |             |              | 
 product_name     | text    |           |          |         | extended |             |              | 
Partition of: products_list FOR VALUES IN ('Clothing')
Partition constraint: ((product_category IS NOT NULL) AND (product_category = 'Clothing'::text))
Indexes:
    "products_list_clothing_pkey" PRIMARY KEY, btree (product_id, product_category)
Access method: heap

\d+ products_list_electronics
                                      Table "s613.products_list_electronics"
      Column      |  Type   | Collation | Nullable | Default | Storage  | Compression | Stats target | Description 
------------------+---------+-----------+----------+---------+----------+-------------+--------------+-------------
 product_id       | integer |           | not null |         | plain    |             |              | 
 product_category | text    |           | not null |         | extended |             |              | 
 product_name     | text    |           |          |         | extended |             |              | 
Partition of: products_list FOR VALUES IN ('Electronics')
Partition constraint: ((product_category IS NOT NULL) AND (product_category = 'Electronics'::text))
Indexes:
    "products_list_electronics_pkey" PRIMARY KEY, btree (product_id, product_category)
Access method: heap

SELECT * FROM get_table_repset_info('products_list'); -- Expect the replication set to change to default
 nspname |          relname          | set_name 
---------+---------------------------+----------
 s613    | products_list             | default
 s613    | products_list_electronics | default
 s613    | products_list_clothing    | default
(3 rows)

SELECT * FROM products_list ORDER BY product_id; -- Expect 3 rows
 product_id | product_category | product_name 
------------+------------------+--------------
          1 | Electronics      | Laptop
          2 | Clothing         | Shirt
          3 | Electronics      | Smartphone
(3 rows)

